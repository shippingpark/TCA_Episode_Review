# #002_SideEffects

### 1. 사이드 이펙트의 소개와 문제점
- **사이드 이펙트 정의**: 함수의 입력과 출력 타입만으로는 파악할 수 없는 함수의 부수적인 행동(예: 글로벌 상태 변경)(print)
- **문제점**: 사이드 이펙트는 코드의 복잡성을 증가시키며, 테스트하기 어렵고, 함수 Composition(조합성)을 해침

### 2. 사이드 이펙트 관리 방법
- **출력으로 사이드 이펙트 포함시키기**: 사이드 이펙트를 함수의 반환 값에 명시적으로 포함시켜, 함수의 사용자가 이를 관리
- 새로운 연산자 `>=>` (fish 연산자)를 도입. 사이드 이펙트를 포함한 함수들을 안전하게 조합  

### 3. `inout` 키워드와 참조 타입 비교
- **`inout` 키워드 사용**: 값 타입에 `inout`을 사용하여 함수 내에서 값을 직접 변경할 수 있음. 이는 참조 타입과 달리 값의 불변성을 유지하면서도 메모리 안전성을 보장
=> 이 부분은 내가 해석을 잘못 하는 건 지 모르겠는데... 아무튼 struct+inout 조합이 identity 가 존재하는 class 사용보다 유리하다고 보는 것 같음  

- **참조 타입의 문제점**: 참조 타입은 여러 부작용을 일으킬 수 있는데, 특히 객체가 여러 곳에서 공유될 때 예측하지 못한 변경이 발생

### 4. 변이 (Mutation) 관리
- **변이의 정의 및 문제점**: 객체의 상태가 변경될 때, 그 변경이 다른 함수나 메서드 호출에 영향을 미칠 수 있음. 
- **값 타입을 이용한 관리 방법**: Swift의 값 타입은 각각의 함수 호출에 복사본을 사용하기 때문에 (불변성 보장), 변이가 로컬 범위에서만 발생하도록 제한. 프로그램의 예측 가능성을 높이고 부작용을 줄이는 데 도움. 

### 5. 새로운 연산자의 도입
- **연산자 `<>` (diamond 연산자) 도입**: `inout` 파라미터를 사용하는 함수들을 조합할 수 있는 새로운 연산자를 도입하여, 조합성 문제를. 해결  
- 이 연산자는 같은 타입의 입력과 출력을 가진 함수들 사이의 조합을 가능하게 하고, 복잡한 조건을 관리.

### 6. 결론. 
사이드 이펙트는 소프트웨어 개발에서 무시할 수 없는 요소.   
Swift에서 제공하는 `inout` 키워드와 값 타입을 활용한 접근 방법은. 1) 사이드 이펙트를 효과적으로 관리하고, 2) 함수의 조합성을 유지하면서도 3) 코드의 안정성과 예측 가능성을 높일 수 있는 강력한 도구를 제공.


# 내 생각 

내 수준 상 말을 좀 어렵게 해서 그렇지, (예시가 연산자라서 그렇지) (연산자 눈에 잘 안들어왔다...). 
핵심은 예측 가능하고, 조합 가능한 함수의 강력함이다.  
다만 의외인 점은, inout을 통한 함수 내 struct의 변경에 관대하다는 점이다.  (이를 장점으로 여긴다는 점이다)  
불변성을 엄격하게 지키기보다, 일정 부분에서는 편의성을 누리는 가치가 더 높다는 의미일까?     

흠. 좋다!  



   



